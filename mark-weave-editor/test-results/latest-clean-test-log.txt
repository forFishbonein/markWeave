CRDT 测试结果 - 干净版本
生成时间: 2025/7/14 04:18:24
================================


> mark-weave-editor@0.1.0 test:crdt
> jest --runInBand --verbose

    ================================================================================


    🚀 CRDT 性能基准测试套件 - benchmark.test.js


    ================================================================================


    --- CRDT 基准结果 ---


    总操作数: 900


    耗时 (ms): 2336.74


    操作 / 毫秒: 0.39


    最终文本长度: 421


    文本前 120 字符: ispsqrpotnykkgfsjudklzipikgzqrdtbbuuroburutttbvtjogdktssggacsdiffgnaweumgcuxitapdrgkctwhdojmbgdfreuymysrzkzzyzpzaetsdtfj


    ================================================================================


    🎲 CRDT 随机模糊测试套件 - fuzz.test.js


    ================================================================================


    🎯 开始执行 50 轮随机操作测试...


    ✅ 50 轮随机操作测试完成


    🔀 开始复杂混合操作测试 (30轮)...


    ✅ 复杂混合操作测试完成


    ⚡ 开始极端边界情况测试 (25轮)...


    ✅ 极端边界情况测试完成


    ⏰ 开始时间戳冲突压力测试 (20轮)...


    ✅ 时间戳冲突压力测试完成


    🌐 开始网络分区恢复测试 (15轮)...


    ✅ 网络分区恢复测试完成


    📊 开始大规模数据量测试 (10轮)...


    ✅ 大规模数据量测试完成


    ================================================================================


    ⚡ CRDT 并发操作测试套件 - concurrent.test.js


    ================================================================================


    📋 测试场景: 基础并发插入 - 两客户端开头同时插入


    📋 测试场景: 两客户端在文档开头同时插入不同字符


    基础文档: hello


    A插入字符 "A" opId: 1752437904467@client


    B插入字符 "B" opId: 1752437904467@client


    🎯 最终结果: "helloBA"


    📋 测试场景: 中间位置并发插入 - 在指定字符后同时插入


    🔧 A客户端ychars初始长度: 0


    🔧 A插入后长度: 9


    🔧 A快照: start_end


    🔧 A的字符详情:


    🔧 B同步后长度: 9


    🔧 B快照: start_end


    📋 测试场景: 两客户端在下划线后同时插入


    基础文档: start_end


    🔍 调试字符查找:


    字符数组长度: 9


    下划线 "_" 的opId: 1752437904470_5@client


    插入后各自状态:


    A: start_Xend


    B: start_Yend


    🎯 最终结果: "start_XYend"


    ✅ 字符正确插入在下划线后


    📋 测试场景: 多字符并发插入 - 使用insertText


    基础文档: base


    A插入后: AAAbase


    B插入后: BBBbase


    🎯 最终结果: "BBBAAAbase"


    📋 测试场景: 三客户端并发插入 - 复杂并发场景


    基础文档: start


    插入后各客户端状态:


    A: start1


    B: start2


    C: start3


    🎯 最终结果:


    A: start123


    B: start123


    C: start123


    ✅ 字符插入在文档末尾（修改后的行为）


    📋 测试场景: 模拟两用户快速连续输入


    基础文档: doc


    快速输入后:


    A: doc_end


    B: doc!


    🎯 最终结果: "doc_end!"


    📝 分析结果: "doc_end!"


    ✅ 字符插入顺序合理（A先于B）


    📋 测试场景: 混合并发操作 - A插入，B删除


    基础文档: hello world


    操作后:


    A: hello worldX


    B: helloorld


    🎯 最终结果: "helloorldX"


    === 混合操作后的可见字符 ===


    [0] "h" → opId: 1752437904488_0@client (时间戳: 1752437904488_0)


    [1] "e" → opId: 1752437904488_1@client (时间戳: 1752437904488_1)


    [2] "l" → opId: 1752437904488_2@client (时间戳: 1752437904488_2)


    [3] "l" → opId: 1752437904488_3@client (时间戳: 1752437904488_3)


    [4] "o" → opId: 1752437904488_4@client (时间戳: 1752437904488_4)


    [5] "o" → opId: 1752437904488_7@client (时间戳: 1752437904488_7)


    [6] "r" → opId: 1752437904489_8@client (时间戳: 1752437904489_8)


    [7] "l" → opId: 1752437904489_9@client (时间戳: 1752437904489_9)


    [8] "d" → opId: 1752437904489_10@client (时间戳: 1752437904489_10)


    [9] "X" → opId: 1752437904489@client (时间戳: 1752437904489)


    实际结果分析: "helloorldX"


    ✅ 删除操作生效，删除了'w '字符


    📋 测试场景: 空文档上的并发插入


    插入后:


    A: A


    B: B


    🎯 空文档并发插入结果: "BA"


    结果长度: 2


    📋 测试场景: 深入分析时间戳和排序规则


    插入时间分析:


      开始时间: 1752437904498


      中间时间: 1752437904498 (时差: 0ms)


      结束时间: 1752437904498 (时差: 0ms)


    实际opId:


      A的opId: 1752437904498@client


      B的opId: 1752437904498@client


    🔍 期望顺序: 按时间戳排序, 实际顺序: T1T2


    字符 "T1" 时间戳: 1752437904498


    字符 "T2" 时间戳: 1752437904498


    🎯 最终排序: "T1T2"


    📋 测试场景: 三客户端极速并发插入


    🔍 baseChars 长度: 4


    🔍 baseChars: [
      { ch: 'b', opId: '1752437904501_0@client' },
      { ch: 'a', opId: '1752437904501_1@client' },
      { ch: 's', opId: '1752437904501_2@client' },
      { ch: 'e', opId: '1752437904501_3@client' }
    ]


    🔍 lastCharId: 1752437904501_3@client


    极速插入后状态:


    A: baseA4A3A2A1A0


    B: baseB4B3B2B1B0


    C: baseC4C3C2C1C0


    🎯 极速并发最终结果:


    A: baseB4B3B2B1B0C4C3C2C1C0A4A3A2A1A0


    B: baseB4B3B2B1B0C4C3C2C1C0A4A3A2A1A0


    C: baseB4B3B2B1B0C4C3C2C1C0A4A3A2A1A0


    📋 测试场景: 模拟网络分区和延迟同步


    分区期间 A-B 同步后:


    A-B 状态: start12


    C 孤立状态: startisolated


    网络恢复前:


    A-B: _partitioned_networkstart12


    C: startisolated


    🎯 网络恢复后最终状态:


    A: _partitioned_networkstart1isolated2


    B: _partitioned_networkstart1isolated2


    C: _partitioned_networkstart1isolated2


    📋 测试场景: 10客户端大规模并发压力测试


    基础文档: shared_document


    执行了 30 个并发操作


    🎯 大规模并发最终结果:


    最终文档: _9_2_9_0_8_2_8_0_7_2_7_0_1_2_1_0_0_20_0_4_2_4_0_2_2_2_0_5_2_5_0_3_2_3_0_6_2_6_0shrddont


    文档长度: 87


    📋 测试场景: 乱序消息同步测试


    模拟乱序同步...


    🎯 乱序同步最终结果:


    A: A2A1B2B1C1


    B: A2A1B2B1C1


    C: A2A1B2B1C1


    📋 测试场景: 相同时间戳冲突解决


    创建了相同时间戳的操作


    🎯 相同时间戳冲突解决结果: AB


    📋 测试场景: 模拟网络丢包和消息丢失


    生成了 4 个更新


    丢包后交付情况:


    A收到: 0 个更新


    B收到: 1 个更新


    C收到: 1 个更新


    丢包后状态:


    A: base14


    B: base214


    C: base31


    🎯 网络恢复后最终状态:


    A: base2314


    B: base2314


    C: base2314


    📋 测试场景: 模拟不同网络延迟


    模拟按延迟顺序传输:


    第1步: C → [A, B] (延迟50ms)


      状态: A="startAC", B="startBC", C="startC"


    第2步: A → [B, C] (延迟100ms)


      状态: A="startAC", B="startBAC", C="startAC"


    第3步: B → [A, C] (延迟300ms)


      状态: A="startBAC", B="startBAC", C="startBAC"


    🎯 延迟模拟最终结果:


    A: startBAC


    B: startBAC


    C: startBAC


    📋 测试场景: 模拟网络重复传输


    原始状态: original


    B添加X后: originalX


    A第一次收到更新: originalX


    模拟重复传输相同更新...


    第2次应用后: originalX


    第3次应用后: originalX


    第4次应用后: originalX


    第5次应用后: originalX


    第6次应用后: originalX


    🎯 重复传输处理结果:


    A: originalX


    B: originalX


    📋 测试场景: 模拟网络带宽限制和批量传输


    生成了 20 个单独更新


    A当前状态: 01234567890123456789


    分成 4 个批次传输


    传输批次 1/4 (5个更新)


    批次1后B状态: 01234


    传输批次 2/4 (5个更新)


    批次2后B状态: 0123456789


    传输批次 3/4 (5个更新)


    批次3后B状态: 012345678901234


    传输批次 4/4 (5个更新)


    批次4后B状态: 01234567890123456789


    🎯 批量传输最终结果:


    A: 01234567890123456789


    B: 01234567890123456789


    ================================================================================


    🎨 CRDT 多格式化测试套件 - multiMark.test.js


    ================================================================================


    📋 测试场景: 嵌套格式化 - 粗体包含斜体


    初始文本: Hello World


    字符范围:


      Hello 范围: 1752437904612_0@client 到 1752437904612_4@client


      World 范围: 1752437904612_6@client 到 1752437904612_10@client


    🔸 A操作: 对整个 'Hello World' 加粗


    🔸 B操作: 对 'World' 部分添加斜体


    🔄 同步格式化操作...


    最终格式操作数量: 2


    格式操作详情:


      1. addMark bold (1752437904614@client)


      2. addMark em (1752437904614@client)


    📄 🎯 嵌套格式化最终结果:


      纯文本: "Hello World"


      格式操作数: 2


      格式化文本: [H:bold][e:bold][l:bold][l:bold][o:bold][ :bold][W:bold,em][o:bold,em][r:bold,em][l:bold,em][d:bold,em]


      格式操作详情:


        1. addMark bold (1752437904614@client)


        2. addMark em (1752437904614@client)




    预期效果: 'Hello World' 全部加粗，'World' 部分还有斜体


    📋 测试场景: 交叉格式化 - A加粗ABC，B斜体DEF，C同时有粗体和斜体


    初始文本: ABCDEF


    字符ID映射:


      A(0): 1752437904618_0@client


      B(1): 1752437904618_1@client


      C(2): 1752437904618_2@client


      D(3): 1752437904618_3@client


      E(4): 1752437904618_4@client


      F(5): 1752437904618_5@client


    🔸 A操作: 对 'ABC' (位置0-2) 加粗


    🔸 B操作: 对 'DEF' (位置3-5) 添加斜体


    🔄 并发同步A和B的格式化操作...


    🔸 C操作: 对 'CD' (位置2-3) 既加粗又斜体


    🔄 三方同步所有格式化操作...


    最终格式操作总数: 4


    粗体操作: 2 个


    斜体操作: 2 个


    预期格式分布:


      A: 粗体, B: 粗体, C: 粗体+斜体, D: 斜体+粗体, E: 斜体, F: 斜体


    📄 🎯 交叉格式化最终结果:


      纯文本: "ABCDEF"


      格式操作数: 4


      格式化文本: [A:bold][B:bold][C:bold,em][D:em,bold][E:em][F:em]


      格式操作详情:


        1. addMark em (1752437904620@client)


        2. addMark bold (1752437904620@client)


        3. addMark bold (1752437904621@client)


        4. addMark em (1752437904621@client)




    📋 测试场景: remove-wins 优先级 - 多客户端格式冲突


    🎯 remove-wins 最终结果: test


    格式操作统计:


    添加操作: 3


    移除操作: 1


    📋 测试场景: 链式格式化操作


    初始段落: This is a complex paragraph for testing.


    目标词汇定位:


      'This' (0-3): 1752437904629_0@client 到 1752437904629_3@client


      'complex' (10-16): 1752437904629_10@client 到 1752437904630_16@client


      'testing' (31-37): 1752437904630_31@client 到 1752437904630_37@client


    🔸 A的格式化操作:


      1. 对 'This' 加粗


      2. 对 'complex' 添加斜体


      3. 对 'testing' 添加链接


    🔸 B的格式化操作:


      1. 对 'complex' 加粗 (与A的斜体叠加)


      2. 对 'This' 添加斜体 (与A的粗体叠加)


    🔄 第一轮同步格式化操作...


    第一轮同步后: This is a complex paragraph for testing.


    第一轮后格式操作数: 5


    🔸 第二轮操作 - 撤销部分格式:


      A: 撤销 'This' 的粗体


      B: 撤销 'complex' 的斜体


    🔄 最终同步所有操作...


    最终格式操作总数: 7


    涉及的格式类型: [ 'bold', 'em', 'link' ]


    添加操作: 5 个, 移除操作: 2 个


    预期最终效果:


      'This': 仅斜体 (粗体被撤销)


      'complex': 仅粗体 (斜体被撤销)


      'testing': 有链接


    📄 🎯 链式格式化最终结果:


      纯文本: "This is a complex paragraph for testing."


      格式操作数: 7


      格式化文本: [T:em][h:em][i:em][s:em] is a [c:bold][o:bold][m:bold][p:bold][l:bold][e:bold][x:bold] paragraph for[ :link][t:link][e:link][s:link][t:link][i:link][n:link]g.


      格式操作详情:


        1. addMark bold (1752437904632@client)


        2. addMark em (1752437904632@client)


        3. addMark link (1752437904632@client)


        4. addMark bold (1752437904633@client)


        5. addMark em (1752437904633@client)


        6. removeMark bold (1752437904635@client)


        7. removeMark em (1752437904635@client)




    📋 测试场景: 边界格式化 - 单字符格式


    📄 🎯 边界格式化结果:


      纯文本: "XY"


      格式操作数: 3


      格式化文本: [X:bold,em,link]Y


      格式操作详情:


        1. addMark bold (1752437904642@client)


        2. addMark em (1752437904642@client)


        3. addMark link (1752437904642@client)




    📋 测试场景: 并发格式化与文本编辑混合


    混合操作后各客户端状态:


    A (插入): eding_tit


    B (格式化): edit


    C (删除+格式化): edt


    🎯 混合场景最终结果:


    A: eding_tt


    B: eding_tt


    C: eding_tt


    ================================================================================


    🔄 CRDT 冲突解决测试套件 - removeWins.test.js


    ================================================================================


    📋 测试场景: remove-wins 冲突解决机制


    初始文本: hi


    字符ID: { hId: '1752437904696_0@client', iId: '1752437904697_1@client' }


    C2同步后: hi


    C1加粗操作完成，C2已同步


    C2取消粗体操作完成，C1已同步


    C1格式操作数量: 2


    C2格式操作数量: 2


    格式操作类型: [ 'addMark-bold', 'removeMark-bold' ]


    🔥 convertCRDTToProseMirrorDoc 被调用


    the newest yformatOps:  []


    the newest ychars []


    ✅ Generated paragraph: []


    📄 ProseMirror 文档结构:


    {
      "type": "doc",
      "content": [
        {
          "type": "paragraph"
        }
      ]
    }


    ⚠️ 文档为空，这符合remove-wins逻辑


    ================================================================================


    🎯 CRDT 确定性测试套件 - deterministic.test.js


    ================================================================================


    📋 测试场景: 两个客户端并发插入文本


    插入后各自状态:


    A: abc


    B: XYZ


    🎯 同步后最终结果:


    A: XYZabc


    B: XYZabc


    ✅ 状态一致性验证: 通过


