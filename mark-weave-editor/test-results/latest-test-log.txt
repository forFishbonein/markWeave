
> mark-weave-editor@0.1.0 test:crdt
> jest --runInBand --verbose

  console.log
    链式插入结果: a132c

      at Object.log (tests/crdt/afterId.test.js:119:13)

  console.log
    删除后状态: ac

      at Object.log (tests/crdt/afterId.test.js:153:13)

  console.warn
    ⚠️ afterId 999999@invalid 未找到，插入到开头

      29 |       const afterIndex = ychars.toArray().findIndex((c) => getProp(c, "opId") === afterId);
      30 |       if (afterIndex === -1) {
    > 31 |         console.warn(`⚠️ afterId ${afterId} 未找到，插入到开头`);
         |                 ^
      32 |         index = 0;
      33 |       } else {
      34 |         // 在afterId后插入，直接插入在afterId+1的位置

      at Object.insertChar (src/crdt/crdtActions.cjs:31:17)
      at insertChar (tests/crdt/afterId.test.js:179:9)
      at Object.<anonymous> (node_modules/expect/build/toThrowMatchers.js:74:11)
      at Object.throwingMatcher [as toThrow] (node_modules/expect/build/index.js:320:21)
      at Object.toThrow (tests/crdt/afterId.test.js:180:12)

  console.log
    并发插入结果: sABtart

      at Object.log (tests/crdt/afterId.test.js:223:13)

  console.log
    多字符插入结果: Hello Beautiful World

      at Object.log (tests/crdt/afterId.test.js:255:13)

  console.log
    --- CRDT 基准结果 ---

      at Object.log (tests/crdt/benchmark.test.js:49:11)

  console.log
    总操作数: 900

      at Object.log (tests/crdt/benchmark.test.js:50:11)

  console.log
    耗时 (ms): 2306.58

      at Object.log (tests/crdt/benchmark.test.js:51:11)

  console.log
    操作 / 毫秒: 0.39

      at Object.log (tests/crdt/benchmark.test.js:52:11)

  console.log
    最终文本长度: 389

      at Object.log (tests/crdt/benchmark.test.js:53:11)

  console.log
    文本前 120 字符: wmtsllcrwplohelstjkwuscoikejapbykyjaujhewvmltdutbjzyeedllzpxgnvchneemhtmjalwhuirfthqctufnmsnzqvdhuidhjchteyfqbnugsoibmkj

      at Object.log (tests/crdt/benchmark.test.js:54:11)

  console.log
    📋 测试场景: 基础并发插入 - 两客户端开头同时插入

      at Object.log (tests/crdt/concurrent.test.js:40:13)

  console.log
    📋 测试场景: 两客户端在文档开头同时插入不同字符

      at Object.log (tests/crdt/concurrent.test.js:48:13)

  console.log
    基础文档: hello

      at Object.log (tests/crdt/concurrent.test.js:49:13)

  console.log
    A插入字符 "A" opId: 1752423873736@client

      at Object.log (tests/crdt/concurrent.test.js:59:13)

  console.log
    B插入字符 "B" opId: 1752423873736@client

      at Object.log (tests/crdt/concurrent.test.js:60:13)

  console.log
    🎯 最终结果: "helloBA"

      at Object.log (tests/crdt/concurrent.test.js:69:13)

  console.log
    📋 测试场景: 中间位置并发插入 - 在指定字符后同时插入

      at Object.log (tests/crdt/concurrent.test.js:83:13)

  console.log
    🔧 A客户端ychars初始长度: 0

      at Object.log (tests/crdt/concurrent.test.js:89:13)

  console.log
    🔧 A插入后长度: 9

      at Object.log (tests/crdt/concurrent.test.js:91:13)

  console.log
    🔧 A快照: start_end

      at Object.log (tests/crdt/concurrent.test.js:92:13)

  console.log
    🔧 A的字符详情:

      at Object.log (tests/crdt/concurrent.test.js:96:15)

  console.log
    🔧 B同步后长度: 9

      at Object.log (tests/crdt/concurrent.test.js:105:13)

  console.log
    🔧 B快照: start_end

      at Object.log (tests/crdt/concurrent.test.js:106:13)

  console.log
    📋 测试场景: 两客户端在下划线后同时插入

      at Object.log (tests/crdt/concurrent.test.js:108:13)

  console.log
    基础文档: start_end

      at Object.log (tests/crdt/concurrent.test.js:109:13)

  console.log
    🔍 调试字符查找:

      at Object.log (tests/crdt/concurrent.test.js:112:13)

  console.log
    字符数组长度: 9

      at Object.log (tests/crdt/concurrent.test.js:113:13)

  console.log
    下划线 "_" 的opId: 1752423873739_5@client

      at Object.log (tests/crdt/concurrent.test.js:133:13)

  console.log
    插入后各自状态:

      at Object.log (tests/crdt/concurrent.test.js:139:13)

  console.log
    A: start_Xend

      at Object.log (tests/crdt/concurrent.test.js:140:13)

  console.log
    B: start_Yend

      at Object.log (tests/crdt/concurrent.test.js:141:13)

  console.log
    🎯 最终结果: "start_YXend"

      at Object.log (tests/crdt/concurrent.test.js:150:13)

  console.log
    ✅ 字符正确插入在下划线后

      at Object.log (tests/crdt/concurrent.test.js:165:15)

  console.log
    📋 测试场景: 多字符并发插入 - 使用insertText

      at Object.log (tests/crdt/concurrent.test.js:181:13)

  console.log
    基础文档: base

      at Object.log (tests/crdt/concurrent.test.js:189:13)

  console.log
    A插入后: AAAbase

      at Object.log (tests/crdt/concurrent.test.js:195:13)

  console.log
    B插入后: BBBbase

      at Object.log (tests/crdt/concurrent.test.js:196:13)

  console.log
    🎯 最终结果: "AAABBBbase"

      at Object.log (tests/crdt/concurrent.test.js:205:13)

  console.log
    📋 测试场景: 三客户端并发插入 - 复杂并发场景

      at Object.log (tests/crdt/concurrent.test.js:219:13)

  console.log
    基础文档: start

      at Object.log (tests/crdt/concurrent.test.js:230:13)

  console.log
    插入后各客户端状态:

      at Object.log (tests/crdt/concurrent.test.js:237:13)

  console.log
    A: start1

      at Object.log (tests/crdt/concurrent.test.js:238:13)

  console.log
    B: start2

      at Object.log (tests/crdt/concurrent.test.js:239:13)

  console.log
    C: start3

      at Object.log (tests/crdt/concurrent.test.js:240:13)

  console.log
    🎯 最终结果:

      at Object.log (tests/crdt/concurrent.test.js:258:13)

  console.log
    A: start213

      at Object.log (tests/crdt/concurrent.test.js:259:13)

  console.log
    B: start213

      at Object.log (tests/crdt/concurrent.test.js:260:13)

  console.log
    C: start213

      at Object.log (tests/crdt/concurrent.test.js:261:13)

  console.log
    ✅ 字符插入在文档末尾（修改后的行为）

      at Object.log (tests/crdt/concurrent.test.js:274:15)

  console.log
    📋 测试场景: 模拟两用户快速连续输入

      at Object.log (tests/crdt/concurrent.test.js:292:13)

  console.log
    基础文档: doc

      at Object.log (tests/crdt/concurrent.test.js:293:13)

  console.log
    快速输入后:

      at Object.log (tests/crdt/concurrent.test.js:303:13)

  console.log
    A: doc_end

      at Object.log (tests/crdt/concurrent.test.js:304:13)

  console.log
    B: doc!

      at Object.log (tests/crdt/concurrent.test.js:305:13)

  console.log
    🎯 最终结果: "doc_end!"

      at Object.log (tests/crdt/concurrent.test.js:314:13)

  console.log
    📝 分析结果: "doc_end!"

      at Object.log (tests/crdt/concurrent.test.js:328:13)

  console.log
    ✅ 字符插入顺序合理（A先于B）

      at Object.log (tests/crdt/concurrent.test.js:332:15)

  console.log
    📋 测试场景: 混合并发操作 - A插入，B删除

      at Object.log (tests/crdt/concurrent.test.js:346:13)

  console.log
    基础文档: hello world

      at Object.log (tests/crdt/concurrent.test.js:347:13)

  console.log
    操作后:

      at Object.log (tests/crdt/concurrent.test.js:353:13)

  console.log
    A: hello worldX

      at Object.log (tests/crdt/concurrent.test.js:354:13)

  console.log
    B: helloorld

      at Object.log (tests/crdt/concurrent.test.js:355:13)

  console.log
    🎯 最终结果: "helloorldX"

      at Object.log (tests/crdt/concurrent.test.js:364:13)

  console.log
    
    === 混合操作后的可见字符 ===

      at log (tests/crdt/concurrent.test.js:11:13)

  console.log
    [0] "h" → opId: 1752423873754_0@client (时间戳: 1752423873754_0)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    [1] "e" → opId: 1752423873754_1@client (时间戳: 1752423873754_1)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    [2] "l" → opId: 1752423873754_2@client (时间戳: 1752423873754_2)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    [3] "l" → opId: 1752423873754_3@client (时间戳: 1752423873754_3)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    [4] "o" → opId: 1752423873754_4@client (时间戳: 1752423873754_4)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    [5] "o" → opId: 1752423873754_7@client (时间戳: 1752423873754_7)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    [6] "r" → opId: 1752423873754_8@client (时间戳: 1752423873754_8)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    [7] "l" → opId: 1752423873754_9@client (时间戳: 1752423873754_9)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    [8] "d" → opId: 1752423873754_10@client (时间戳: 1752423873754_10)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    [9] "X" → opId: 1752423873755@client (时间戳: 1752423873755)

      at log (tests/crdt/concurrent.test.js:15:15)
          at Array.forEach (<anonymous>)

  console.log
    实际结果分析: "helloorldX"

      at Object.log (tests/crdt/concurrent.test.js:376:13)

  console.log
    ✅ 删除操作生效，删除了'w '字符

      at Object.log (tests/crdt/concurrent.test.js:387:15)

  console.log
    📋 测试场景: 空文档上的并发插入

      at Object.log (tests/crdt/concurrent.test.js:406:13)

  console.log
    插入后:

      at Object.log (tests/crdt/concurrent.test.js:412:13)

  console.log
    A: A

      at Object.log (tests/crdt/concurrent.test.js:413:13)

  console.log
    B: B

      at Object.log (tests/crdt/concurrent.test.js:414:13)

  console.log
    🎯 空文档并发插入结果: "AB"

      at Object.log (tests/crdt/concurrent.test.js:423:13)

  console.log
    结果长度: 2

      at Object.log (tests/crdt/concurrent.test.js:424:13)

  console.log
    📋 测试场景: 深入分析时间戳和排序规则

      at Object.log (tests/crdt/concurrent.test.js:448:13)

  console.log
    插入时间分析:

      at Object.log (tests/crdt/concurrent.test.js:457:13)

  console.log
      开始时间: 1752423873763

      at Object.log (tests/crdt/concurrent.test.js:458:13)

  console.log
      中间时间: 1752423873763 (时差: 0ms)

      at Object.log (tests/crdt/concurrent.test.js:459:13)

  console.log
      结束时间: 1752423873763 (时差: 0ms)

      at Object.log (tests/crdt/concurrent.test.js:460:13)

  console.log
    实际opId:

      at Object.log (tests/crdt/concurrent.test.js:466:13)

  console.log
      A的opId: 1752423873763@client

      at Object.log (tests/crdt/concurrent.test.js:467:13)

  console.log
      B的opId: 1752423873763@client

      at Object.log (tests/crdt/concurrent.test.js:468:13)

  console.log
    🔍 期望顺序: 按时间戳排序, 实际顺序: T1T2

      at log (tests/crdt/concurrent.test.js:24:13)

  console.log
    字符 "T1" 时间戳: 1752423873763

      at log (tests/crdt/concurrent.test.js:33:15)
          at Array.forEach (<anonymous>)

  console.log
    字符 "T2" 时间戳: 1752423873763

      at log (tests/crdt/concurrent.test.js:33:15)
          at Array.forEach (<anonymous>)

  console.log
    🎯 最终排序: "T1T2"

      at Object.log (tests/crdt/concurrent.test.js:477:13)

  console.log
    📋 测试场景: 三客户端极速并发插入

      at Object.log (tests/crdt/concurrent.test.js:487:13)

  console.log
    🔍 baseChars 长度: 4

      at Object.log (tests/crdt/concurrent.test.js:496:13)

  console.log
    🔍 baseChars: [
      { ch: 'b', opId: '1752423873766_0@client' },
      { ch: 'a', opId: '1752423873766_1@client' },
      { ch: 's', opId: '1752423873766_2@client' },
      { ch: 'e', opId: '1752423873766_3@client' }
    ]

      at Object.log (tests/crdt/concurrent.test.js:497:13)

  console.log
    🔍 lastCharId: 1752423873766_3@client

      at Object.log (tests/crdt/concurrent.test.js:514:13)

  console.log
    极速插入后状态:

      at Object.log (tests/crdt/concurrent.test.js:523:13)

  console.log
    A: baseA4A3A2A1A0

      at Object.log (tests/crdt/concurrent.test.js:524:13)

  console.log
    B: baseB4B3B2B1B0

      at Object.log (tests/crdt/concurrent.test.js:525:13)

  console.log
    C: baseC4C3C2C1C0

      at Object.log (tests/crdt/concurrent.test.js:526:13)

  console.log
    🎯 极速并发最终结果:

      at Object.log (tests/crdt/concurrent.test.js:544:13)

  console.log
    A: baseC4C3C2C1C0B4B3B2B1B0A4A3A2A1A0

      at Object.log (tests/crdt/concurrent.test.js:545:13)

  console.log
    B: baseC4C3C2C1C0B4B3B2B1B0A4A3A2A1A0

      at Object.log (tests/crdt/concurrent.test.js:546:13)

  console.log
    C: baseC4C3C2C1C0B4B3B2B1B0A4A3A2A1A0

      at Object.log (tests/crdt/concurrent.test.js:547:13)

  console.log
    📋 测试场景: 模拟网络分区和延迟同步

      at Object.log (tests/crdt/concurrent.test.js:567:13)

  console.log
    分区期间 A-B 同步后:

      at Object.log (tests/crdt/concurrent.test.js:584:13)

  console.log
    A-B 状态: start21

      at Object.log (tests/crdt/concurrent.test.js:585:13)

  console.log
    C 孤立状态: startisolated

      at Object.log (tests/crdt/concurrent.test.js:586:13)

  console.log
    网络恢复前:

      at Object.log (tests/crdt/concurrent.test.js:596:13)

  console.log
    A-B: _network_partitionedstart21

      at Object.log (tests/crdt/concurrent.test.js:597:13)

  console.log
    C: startisolated

      at Object.log (tests/crdt/concurrent.test.js:598:13)

  console.log
    🎯 网络恢复后最终状态:

      at Object.log (tests/crdt/concurrent.test.js:614:13)

  console.log
    A: _network_partitionedstart21isolated

      at Object.log (tests/crdt/concurrent.test.js:615:13)

  console.log
    B: _network_partitionedstart21isolated

      at Object.log (tests/crdt/concurrent.test.js:616:13)

  console.log
    C: _network_partitionedstart21isolated

      at Object.log (tests/crdt/concurrent.test.js:617:13)

  console.log
    📋 测试场景: 10客户端大规模并发压力测试

      at Object.log (tests/crdt/concurrent.test.js:629:13)

  console.log
    基础文档: shared_document

      at Object.log (tests/crdt/concurrent.test.js:643:13)

  console.log
    执行了 30 个并发操作

      at Object.log (tests/crdt/concurrent.test.js:665:13)

  console.log
    🎯 大规模并发最终结果:

      at Object.log (tests/crdt/concurrent.test.js:682:13)

  console.log
    最终文档: _1_2__0_7_2__0_3_2_3_0_5_2_5_0_4_2_4_0_8_2_8_0_9_2_9_0_6_2_6_0_2_2_2_0_0_2_0_0ard_cment

      at Object.log (tests/crdt/concurrent.test.js:683:13)

  console.log
    文档长度: 87

      at Object.log (tests/crdt/concurrent.test.js:684:13)

  console.log
    📋 测试场景: 乱序消息同步测试

      at Object.log (tests/crdt/concurrent.test.js:706:13)

  console.log
    模拟乱序同步...

      at Object.log (tests/crdt/concurrent.test.js:725:13)

  console.log
    🎯 乱序同步最终结果:

      at Object.log (tests/crdt/concurrent.test.js:747:13)

  console.log
    A: B2B1C1A2A1

      at Object.log (tests/crdt/concurrent.test.js:748:13)

  console.log
    B: B2B1C1A2A1

      at Object.log (tests/crdt/concurrent.test.js:749:13)

  console.log
    C: B2B1C1A2A1

      at Object.log (tests/crdt/concurrent.test.js:750:13)

  console.log
    📋 测试场景: 相同时间戳冲突解决

      at Object.log (tests/crdt/concurrent.test.js:768:13)

  console.log
    创建了相同时间戳的操作

      at Object.log (tests/crdt/concurrent.test.js:781:15)

  console.log
    🎯 相同时间戳冲突解决结果: BA

      at Object.log (tests/crdt/concurrent.test.js:793:15)

  console.log
    📋 测试场景: 模拟网络丢包和消息丢失

      at Object.log (tests/crdt/concurrent.test.js:810:13)

  console.log
    生成了 4 个更新

      at Object.log (tests/crdt/concurrent.test.js:831:13)

  console.log
    丢包后交付情况:

      at Object.log (tests/crdt/concurrent.test.js:853:13)

  console.log
    A收到: 1 个更新

      at Object.log (tests/crdt/concurrent.test.js:854:13)

  console.log
    B收到: 2 个更新

      at Object.log (tests/crdt/concurrent.test.js:855:13)

  console.log
    C收到: 2 个更新

      at Object.log (tests/crdt/concurrent.test.js:856:13)

  console.log
    丢包后状态:

      at Object.log (tests/crdt/concurrent.test.js:863:13)

  console.log
    A: base214

      at Object.log (tests/crdt/concurrent.test.js:864:13)

  console.log
    B: base214

      at Object.log (tests/crdt/concurrent.test.js:865:13)

  console.log
    C: base231

      at Object.log (tests/crdt/concurrent.test.js:866:13)

  console.log
    🎯 网络恢复后最终状态:

      at Object.log (tests/crdt/concurrent.test.js:879:13)

  console.log
    A: base2314

      at Object.log (tests/crdt/concurrent.test.js:880:13)

  console.log
    B: base2314

      at Object.log (tests/crdt/concurrent.test.js:881:13)

  console.log
    C: base2314

      at Object.log (tests/crdt/concurrent.test.js:882:13)

  console.log
    📋 测试场景: 模拟不同网络延迟

      at Object.log (tests/crdt/concurrent.test.js:899:13)

  console.log
    模拟按延迟顺序传输:

      at Object.log (tests/crdt/concurrent.test.js:937:13)

  console.log
    第1步: C → [A, B] (延迟50ms)

      at log (tests/crdt/concurrent.test.js:939:15)
          at Array.forEach (<anonymous>)

  console.log
      状态: A="startCA", B="startCB", C="startC"

      at log (tests/crdt/concurrent.test.js:953:15)
          at Array.forEach (<anonymous>)

  console.log
    第2步: A → [B, C] (延迟100ms)

      at log (tests/crdt/concurrent.test.js:939:15)
          at Array.forEach (<anonymous>)

  console.log
      状态: A="startCA", B="startCBA", C="startCA"

      at log (tests/crdt/concurrent.test.js:953:15)
          at Array.forEach (<anonymous>)

  console.log
    第3步: B → [A, C] (延迟300ms)

      at log (tests/crdt/concurrent.test.js:939:15)
          at Array.forEach (<anonymous>)

  console.log
      状态: A="startCBA", B="startCBA", C="startCBA"

      at log (tests/crdt/concurrent.test.js:953:15)
          at Array.forEach (<anonymous>)

  console.log
    🎯 延迟模拟最终结果:

      at Object.log (tests/crdt/concurrent.test.js:962:13)

  console.log
    A: startCBA

      at Object.log (tests/crdt/concurrent.test.js:963:13)

  console.log
    B: startCBA

      at Object.log (tests/crdt/concurrent.test.js:964:13)

  console.log
    C: startCBA

      at Object.log (tests/crdt/concurrent.test.js:965:13)

  console.log
    📋 测试场景: 模拟网络重复传输

      at Object.log (tests/crdt/concurrent.test.js:980:13)

  console.log
    原始状态: original

      at Object.log (tests/crdt/concurrent.test.js:989:13)

  console.log
    B添加X后: originalX

      at Object.log (tests/crdt/concurrent.test.js:990:13)

  console.log
    A第一次收到更新: originalX

      at Object.log (tests/crdt/concurrent.test.js:994:13)

  console.log
    模拟重复传输相同更新...

      at Object.log (tests/crdt/concurrent.test.js:997:13)

  console.log
    第2次应用后: originalX

      at Object.log (tests/crdt/concurrent.test.js:1000:15)

  console.log
    第3次应用后: originalX

      at Object.log (tests/crdt/concurrent.test.js:1000:15)

  console.log
    第4次应用后: originalX

      at Object.log (tests/crdt/concurrent.test.js:1000:15)

  console.log
    第5次应用后: originalX

      at Object.log (tests/crdt/concurrent.test.js:1000:15)

  console.log
    第6次应用后: originalX

      at Object.log (tests/crdt/concurrent.test.js:1000:15)

  console.log
    🎯 重复传输处理结果:

      at Object.log (tests/crdt/concurrent.test.js:1006:13)

  console.log
    A: originalX

      at Object.log (tests/crdt/concurrent.test.js:1007:13)

  console.log
    B: originalX

      at Object.log (tests/crdt/concurrent.test.js:1008:13)

  console.log
    📋 测试场景: 模拟网络带宽限制和批量传输

      at Object.log (tests/crdt/concurrent.test.js:1024:13)

  console.log
    生成了 20 个单独更新

      at Object.log (tests/crdt/concurrent.test.js:1033:13)

  console.log
    A当前状态: 01234567890123456789

      at Object.log (tests/crdt/concurrent.test.js:1034:13)

  console.log
    分成 4 个批次传输

      at Object.log (tests/crdt/concurrent.test.js:1043:13)

  console.log
    传输批次 1/4 (5个更新)

      at log (tests/crdt/concurrent.test.js:1047:15)
          at Array.forEach (<anonymous>)

  console.log
    批次1后B状态: 01234

      at log (tests/crdt/concurrent.test.js:1055:15)
          at Array.forEach (<anonymous>)

  console.log
    传输批次 2/4 (5个更新)

      at log (tests/crdt/concurrent.test.js:1047:15)
          at Array.forEach (<anonymous>)

  console.log
    批次2后B状态: 0123456789

      at log (tests/crdt/concurrent.test.js:1055:15)
          at Array.forEach (<anonymous>)

  console.log
    传输批次 3/4 (5个更新)

      at log (tests/crdt/concurrent.test.js:1047:15)
          at Array.forEach (<anonymous>)

  console.log
    批次3后B状态: 012345678901234

      at log (tests/crdt/concurrent.test.js:1055:15)
          at Array.forEach (<anonymous>)

  console.log
    传输批次 4/4 (5个更新)

      at log (tests/crdt/concurrent.test.js:1047:15)
          at Array.forEach (<anonymous>)

  console.log
    批次4后B状态: 01234567890123456789

      at log (tests/crdt/concurrent.test.js:1055:15)
          at Array.forEach (<anonymous>)

  console.log
    🎯 批量传输最终结果:

      at Object.log (tests/crdt/concurrent.test.js:1061:13)

  console.log
    A: 01234567890123456789

      at Object.log (tests/crdt/concurrent.test.js:1062:13)

  console.log
    B: 01234567890123456789

      at Object.log (tests/crdt/concurrent.test.js:1063:13)

  console.log
    🔍 A client rawFormatOps: [
      {
        opId: '1752423873868@client',
        action: 'addMark',
        markType: 'bold',
        start: { type: 'before', opId: '1752423873867_0@client' },
        end: { type: 'after', opId: '1752423873867_1@client' },
        timestamp: 1752423873868
      },
      {
        opId: '1752423873868@client',
        action: 'addMark',
        markType: 'em',
        start: { type: 'before', opId: '1752423873867_1@client' },
        end: { type: 'after', opId: '1752423873867_1@client' },
        timestamp: 1752423873868
      },
      {
        opId: '1752423873868@client',
        action: 'addMark',
        markType: 'link',
        start: { type: 'before', opId: '1752423873867_0@client' },
        end: { type: 'after', opId: '1752423873867_0@client' },
        attrs: { href: 'https://example.com' },
        timestamp: 1752423873868
      },
      {
        opId: '1752423873869@client',
        action: 'removeMark',
        markType: 'bold',
        start: { type: 'before', opId: '1752423873867_0@client' },
        end: { type: 'after', opId: '1752423873867_1@client' },
        timestamp: 1752423873869
      },
      {
        opId: '1752423873869@client',
        action: 'removeMark',
        markType: 'em',
        start: { type: 'before', opId: '1752423873867_1@client' },
        end: { type: 'after', opId: '1752423873867_1@client' },
        timestamp: 1752423873869
      }
    ]

      at Object.log (tests/crdt/multiMark.test.js:47:13)

  console.log
    📋 测试场景: 嵌套格式化 - 粗体包含斜体

      at Object.log (tests/crdt/multiMark.test.js:81:13)

  console.log
    🎯 嵌套格式化结果: Hello World

      at Object.log (tests/crdt/multiMark.test.js:96:13)

  console.log
    📋 测试场景: 交叉格式化 - A加粗ABC，B斜体DEF，C同时有粗体和斜体

      at Object.log (tests/crdt/multiMark.test.js:118:13)

  console.log
    🎯 交叉格式化最终结果: ABCDEF

      at Object.log (tests/crdt/multiMark.test.js:145:13)

  console.log
    📋 测试场景: remove-wins 优先级 - 多客户端格式冲突

      at Object.log (tests/crdt/multiMark.test.js:173:13)

  console.log
    🎯 remove-wins 最终结果: test

      at Object.log (tests/crdt/multiMark.test.js:204:13)

  console.log
    格式操作统计:

      at Object.log (tests/crdt/multiMark.test.js:216:13)

  console.log
    添加操作: 3

      at Object.log (tests/crdt/multiMark.test.js:217:13)

  console.log
    移除操作: 1

      at Object.log (tests/crdt/multiMark.test.js:218:13)

  console.log
    📋 测试场景: 链式格式化操作

      at Object.log (tests/crdt/multiMark.test.js:233:13)

  console.log
    第一轮同步后: This is a complex paragraph for testing.

      at Object.log (tests/crdt/multiMark.test.js:253:13)

  console.log
    🎯 链式格式化最终结果: This is a complex paragraph for testing.

      at Object.log (tests/crdt/multiMark.test.js:266:13)

  console.log
    📋 测试场景: 边界格式化 - 单字符格式

      at Object.log (tests/crdt/multiMark.test.js:286:13)

  console.log
    🎯 边界格式化结果: XY

      at Object.log (tests/crdt/multiMark.test.js:315:13)

  console.log
    📋 测试场景: 并发格式化与文本编辑混合

      at Object.log (tests/crdt/multiMark.test.js:330:13)

  console.log
    混合操作后各客户端状态:

      at Object.log (tests/crdt/multiMark.test.js:351:13)

  console.log
    A (插入): eding_tit

      at Object.log (tests/crdt/multiMark.test.js:352:13)

  console.log
    B (格式化): edit

      at Object.log (tests/crdt/multiMark.test.js:353:13)

  console.log
    C (删除+格式化): edt

      at Object.log (tests/crdt/multiMark.test.js:354:13)

  console.log
    🎯 混合场景最终结果:

      at Object.log (tests/crdt/multiMark.test.js:372:13)

  console.log
    A: eding_tt

      at Object.log (tests/crdt/multiMark.test.js:373:13)

  console.log
    B: eding_tt

      at Object.log (tests/crdt/multiMark.test.js:374:13)

  console.log
    C: eding_tt

      at Object.log (tests/crdt/multiMark.test.js:375:13)

  console.log
    🔥 convertCRDTToProseMirrorDoc 被调用

      at log (src/crdt/crdtUtils.js:26:11)

  console.log
    the newest yformatOps:  []

      at log (src/crdt/crdtUtils.js:27:11)

  console.log
    the newest ychars []

      at log (src/crdt/crdtUtils.js:32:11)

  console.log
    ✅ Generated paragraph: []

      at log (src/crdt/crdtUtils.js:105:11)

  console.log
    🔍 初始字符: [
      { ch: 'a', opId: '1752423873996_0@client' },
      { ch: 'b', opId: '1752423873997_1@client' },
      { ch: 'c', opId: '1752423873997_2@client' },
      { ch: 'd', opId: '1752423873997_3@client' },
      { ch: 'e', opId: '1752423873997_4@client' },
      { ch: 'f', opId: '1752423873997_5@client' }
    ]

      at Object.log (tests/crdt/deleteRange.test.js:20:11)

  console.log
    🔍 最终C1状态:

      at Object.log (tests/crdt/deleteRange.test.js:39:11)

  console.log
    🔍 最终C2状态:

      at Object.log (tests/crdt/deleteRange.test.js:40:11)

