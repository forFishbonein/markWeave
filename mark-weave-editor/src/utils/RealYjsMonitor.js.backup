/*
 * @FilePath: RealYjsMonitor.js
 * @Author: Aron
 * @Date: 2025-01-27
 * @Description: çœŸå®Yjsæ€§èƒ½ç›‘æ§å™¨ - é€šè¿‡äº‹ä»¶ç›‘å¬è·å–çœŸå®æ•°æ®
 */

/**
 * çœŸå®Yjsæ€§èƒ½ç›‘æ§å™¨
 * é€šè¿‡ç›‘å¬Yjsæ–‡æ¡£äº‹ä»¶å’ŒWebSocketäº‹ä»¶æ¥è·å–çœŸå®æ€§èƒ½æ•°æ®
 */
class RealYjsMonitor {
  constructor() {
    this.isMonitoring = false;
    this.startTime = null;

    // æ€§èƒ½æ•°æ®
    this.metrics = {
      // æ–‡æ¡£æ“ä½œ
      documentUpdates: 0,
      totalUpdateSize: 0,
      updateTimes: [],

      // ç½‘ç»œæ•°æ®
      networkEvents: [],
      connectionEvents: [],

      // ç”¨æˆ·æ“ä½œ
      userOperations: [],
      keystrokes: 0,

      // åä½œæ•°æ®
      collaborators: new Map(),
      awarenessChanges: [],

      // å»¶è¿Ÿæ•°æ®
      operationLatencies: [],
      networkLatencies: [],
    };

    // ç»‘å®šæ–¹æ³•
    this.handleDocumentUpdate = this.handleDocumentUpdate.bind(this);
    this.handleAwarenessChange = this.handleAwarenessChange.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.handleProviderStatus = this.handleProviderStatus.bind(this);
  }

  /**
   * å¼€å§‹ç›‘æ§
   */
  startMonitoring(ydoc, awareness, provider) {
    if (this.isMonitoring) {
      console.warn("ç›‘æ§å·²ç»åœ¨è¿è¡Œä¸­");
      return;
    }

    this.isMonitoring = true;
    this.startTime = performance.now();
    this.ydoc = ydoc;
    this.awareness = awareness;
    this.provider = provider;

    console.log("ğŸš€ å¼€å§‹çœŸå®Yjsæ€§èƒ½ç›‘æ§");

    // ç›‘å¬æ–‡æ¡£æ›´æ–°
    if (ydoc) {
      ydoc.on("update", this.handleDocumentUpdate);
      console.log("âœ… å·²ç›‘å¬æ–‡æ¡£æ›´æ–°äº‹ä»¶");
    }

    // ç›‘å¬awarenesså˜åŒ–
    if (awareness) {
      awareness.on("change", this.handleAwarenessChange);
      console.log("âœ… å·²ç›‘å¬awarenesså˜åŒ–äº‹ä»¶");
    }

    // ç›‘å¬WebSocketçŠ¶æ€
    if (provider) {
      provider.on("status", this.handleProviderStatus);
      console.log("âœ… å·²ç›‘å¬WebSocketçŠ¶æ€äº‹ä»¶");
    }

    // ç›‘å¬é”®ç›˜è¾“å…¥
    document.addEventListener("keydown", this.handleKeydown);
    console.log("âœ… å·²ç›‘å¬é”®ç›˜è¾“å…¥äº‹ä»¶");

    // æ‹¦æˆªWebSocketæ¥ç›‘æ§ç½‘ç»œæ•°æ®
    this.interceptWebSocket();
  }

  /**
   * åœæ­¢ç›‘æ§
   */
  stopMonitoring() {
    if (!this.isMonitoring) return;

    this.isMonitoring = false;

    // ç§»é™¤äº‹ä»¶ç›‘å¬
    if (this.ydoc) {
      this.ydoc.off("update", this.handleDocumentUpdate);
    }
    if (this.awareness) {
      this.awareness.off("change", this.handleAwarenessChange);
    }
    if (this.provider) {
      this.provider.off("status", this.handleProviderStatus);
    }

    document.removeEventListener("keydown", this.handleKeydown);

    console.log("â¹ï¸ å·²åœæ­¢Yjsæ€§èƒ½ç›‘æ§");
  }

  /**
   * å¤„ç†æ–‡æ¡£æ›´æ–°äº‹ä»¶
   */
  handleDocumentUpdate(update, origin) {
    const timestamp = performance.now();
    const updateSize = update.length;

    this.metrics.documentUpdates++;
    this.metrics.totalUpdateSize += updateSize;
    this.metrics.updateTimes.push(timestamp);

    // è®°å½•æ“ä½œå»¶è¿Ÿï¼ˆä»ç”¨æˆ·è¾“å…¥åˆ°æ–‡æ¡£æ›´æ–°çš„æ—¶é—´ï¼‰
    if (this.lastUserOperation) {
      const latency = timestamp - this.lastUserOperation;
      this.metrics.operationLatencies.push({
        latency,
        timestamp,
        updateSize,
        origin,
      });

      console.log(
        `ğŸ“Š æ–‡æ¡£æ›´æ–°å»¶è¿Ÿ: ${latency.toFixed(2)}ms, å¤§å°: ${updateSize}å­—èŠ‚`
      );
    }

    console.log(
      `ğŸ“ æ–‡æ¡£æ›´æ–° #${this.metrics.documentUpdates}, å¤§å°: ${updateSize}å­—èŠ‚, æ¥æº: ${origin}`
    );
  }

  /**
   * å¤„ç†awarenesså˜åŒ–
   */
  handleAwarenessChange(changes) {
    const timestamp = performance.now();

    // è®°å½•ç”¨æˆ·åŠ å…¥/ç¦»å¼€
    changes.added.forEach((clientId) => {
      const state = this.awareness.getStates().get(clientId);
      if (state?.user) {
        this.metrics.collaborators.set(clientId, {
          user: state.user,
          joinTime: timestamp,
        });
        console.log(`ğŸ‘¥ ç”¨æˆ·åŠ å…¥: ${state.user.name || clientId}`);
      }
    });

    changes.removed.forEach((clientId) => {
      const collaborator = this.metrics.collaborators.get(clientId);
      if (collaborator) {
        const sessionDuration = timestamp - collaborator.joinTime;
        console.log(
          `ğŸ‘‹ ç”¨æˆ·ç¦»å¼€: ${
            collaborator.user.name || clientId
          }, ä¼šè¯æ—¶é•¿: ${sessionDuration.toFixed(0)}ms`
        );
        this.metrics.collaborators.delete(clientId);
      }
    });

    // è®°å½•awarenesså˜åŒ–
    this.metrics.awarenessChanges.push({
      timestamp,
      added: changes.added.length,
      updated: changes.updated.length,
      removed: changes.removed.length,
      totalUsers: this.awareness.getStates().size,
    });
  }

  /**
   * å¤„ç†é”®ç›˜è¾“å…¥
   */
  handleKeydown(event) {
    // åªè®°å½•ç¼–è¾‘ç›¸å…³çš„æŒ‰é”®
    if (
      event.target.closest("[contenteditable]") ||
      event.target.closest(".ProseMirror")
    ) {
      this.metrics.keystrokes++;
      this.lastUserOperation = performance.now();

      this.metrics.userOperations.push({
        timestamp: this.lastUserOperation,
        key: event.key,
        keyCode: event.keyCode,
        ctrlKey: event.ctrlKey,
        shiftKey: event.shiftKey,
        altKey: event.altKey,
      });
    }
  }

  /**
   * å¤„ç†WebSocketçŠ¶æ€å˜åŒ–
   */
  handleProviderStatus(event) {
    const timestamp = performance.now();

    this.metrics.connectionEvents.push({
      timestamp,
      status: event.status,
    });

    console.log(`ğŸ”Œ WebSocketçŠ¶æ€: ${event.status}`);

    // å¦‚æœæ˜¯è¿æ¥å»ºç«‹ï¼Œå¼€å§‹pingæµ‹è¯•
    if (event.status === "connected") {
      this.startPingTest();
    }
  }

  /**
   * æ‹¦æˆªWebSocketè¿›è¡Œç½‘ç»œç›‘æ§
   */
  interceptWebSocket() {
    if (this.provider && this.provider.ws) {
      const ws = this.provider.ws;

      // æ‹¦æˆªsendæ–¹æ³•
      const originalSend = ws.send.bind(ws);
      ws.send = (data) => {
        const timestamp = performance.now();
        const size = data.length || data.byteLength || 0;

        this.metrics.networkEvents.push({
          type: "send",
          timestamp,
          size,
        });

        console.log(`ğŸ“¤ å‘é€æ•°æ®: ${size}å­—èŠ‚`);
        return originalSend(data);
      };

      // ç›‘å¬æ¶ˆæ¯æ¥æ”¶
      ws.addEventListener("message", (event) => {
        const timestamp = performance.now();
        const size = event.data.length || event.data.byteLength || 0;

        this.metrics.networkEvents.push({
          type: "receive",
          timestamp,
          size,
        });

        console.log(`ğŸ“¥ æ¥æ”¶æ•°æ®: ${size}å­—èŠ‚`);
      });
    }
  }

  /**
   * å¼€å§‹pingæµ‹è¯•æ¥æµ‹é‡ç½‘ç»œå»¶è¿Ÿ
   */
  startPingTest() {
    if (!this.provider || !this.provider.ws) return;

    const pingInterval = setInterval(() => {
      if (
        !this.isMonitoring ||
        !this.provider.ws ||
        this.provider.ws.readyState !== WebSocket.OPEN
      ) {
        clearInterval(pingInterval);
        return;
      }

      const startTime = performance.now();
      const pingId = Math.random().toString(36).substr(2, 9);

      // å‘é€pingï¼ˆé€šè¿‡awarenessæ›´æ–°ï¼‰
      this.awareness.setLocalStateField("ping", {
        id: pingId,
        timestamp: startTime,
      });

      // ç›‘å¬pongï¼ˆé€šè¿‡awarenesså˜åŒ–ï¼‰
      const handlePong = (changes) => {
        const states = this.awareness.getStates();
        states.forEach((state, clientId) => {
          if (
            state.ping &&
            state.ping.id === pingId &&
            clientId !== this.awareness.clientID
          ) {
            const endTime = performance.now();
            const latency = endTime - startTime;

            this.metrics.networkLatencies.push({
              latency,
              timestamp: endTime,
              clientId,
            });

            console.log(`ğŸ“ ç½‘ç»œå»¶è¿Ÿ: ${latency.toFixed(2)}ms`);
            this.awareness.off("change", handlePong);
          }
        });
      };

      this.awareness.on("change", handlePong);

      // 5ç§’åæ¸…ç†
      setTimeout(() => {
        this.awareness.off("change", handlePong);
      }, 5000);
    }, 3000); // æ¯3ç§’pingä¸€æ¬¡
  }

  /**
   * è·å–å®æ—¶æ€§èƒ½ç»Ÿè®¡
   */
  getPerformanceStats() {
    if (!this.isMonitoring || !this.startTime) {
      return null;
    }

    const now = performance.now();
    const monitoringDuration = (now - this.startTime) / 1000; // ç§’

    // è®¡ç®—æœ€è¿‘çš„ç»Ÿè®¡æ•°æ®
    const recentWindow = 5000; // æœ€è¿‘5ç§’
    const recentTime = now - recentWindow;

    const recentUpdates = this.metrics.updateTimes.filter(
      (t) => t > recentTime
    );
    const recentNetworkEvents = this.metrics.networkEvents.filter(
      (e) => e.timestamp > recentTime
    );
    const recentLatencies = this.metrics.operationLatencies.filter(
      (l) => l.timestamp > recentTime
    );

    // è®¡ç®—å»¶è¿Ÿç»Ÿè®¡
    const latencies = this.metrics.operationLatencies.map((l) => l.latency);
    const avgLatency =
      latencies.length > 0
        ? latencies.reduce((a, b) => a + b, 0) / latencies.length
        : 0;
    const sortedLatencies = [...latencies].sort((a, b) => a - b);
    const p95Latency =
      sortedLatencies.length > 0
        ? sortedLatencies[Math.floor(sortedLatencies.length * 0.95)] || 0
        : 0;

    // è®¡ç®—ç½‘ç»œå»¶è¿Ÿ
    const networkLatencies = this.metrics.networkLatencies.map(
      (l) => l.latency
    );
    const avgNetworkLatency =
      networkLatencies.length > 0
        ? networkLatencies.reduce((a, b) => a + b, 0) / networkLatencies.length
        : 0;

    // è®¡ç®—å¸¦å®½
    const sentBytes = this.metrics.networkEvents
      .filter((e) => e.type === "send")
      .reduce((sum, e) => sum + e.size, 0);
    const receivedBytes = this.metrics.networkEvents
      .filter((e) => e.type === "receive")
      .reduce((sum, e) => sum + e.size, 0);

    return {
      // åŸºæœ¬ä¿¡æ¯
      monitoringDuration,
      isConnected:
        this.provider &&
        this.provider.ws &&
        this.provider.ws.readyState === WebSocket.OPEN,

      // æ–‡æ¡£æ“ä½œç»Ÿè®¡
      documentUpdates: this.metrics.documentUpdates,
      totalUpdateSize: this.metrics.totalUpdateSize,
      updatesPerSecond: this.metrics.documentUpdates / monitoringDuration,
      avgUpdateSize:
        this.metrics.documentUpdates > 0
          ? this.metrics.totalUpdateSize / this.metrics.documentUpdates
          : 0,

      // ç”¨æˆ·æ“ä½œç»Ÿè®¡
      keystrokes: this.metrics.keystrokes,
      keystrokesPerSecond: this.metrics.keystrokes / monitoringDuration,

      // å»¶è¿Ÿç»Ÿè®¡
      avgLatency,
      p95Latency,
      avgNetworkLatency,
      latencySamples: latencies.length,
      networkLatencySamples: networkLatencies.length,

      // ç½‘ç»œç»Ÿè®¡
      sentBytes,
      receivedBytes,
      totalBytes: sentBytes + receivedBytes,
      bandwidthKBps: (sentBytes + receivedBytes) / 1024 / monitoringDuration,

      // åä½œç»Ÿè®¡
      activeCollaborators: this.metrics.collaborators.size,
      totalAwarenessChanges: this.metrics.awarenessChanges.length,

      // æœ€è¿‘æ´»åŠ¨
      recentUpdates: recentUpdates.length,
      recentNetworkEvents: recentNetworkEvents.length,
      recentLatencies: recentLatencies.length,

      // åŸå§‹æ•°æ®
      rawData: {
        operationLatencies: this.metrics.operationLatencies,
        networkLatencies: this.metrics.networkLatencies,
        networkEvents: this.metrics.networkEvents,
        awarenessChanges: this.metrics.awarenessChanges,
        userOperations: this.metrics.userOperations,
      },
    };
  }

  /**
   * å¯¼å‡ºå­¦æœ¯æ•°æ®
   */
  exportAcademicData() {
    const stats = this.getPerformanceStats();
    if (!stats) return null;

    return {
      // åŸºæœ¬ä¿¡æ¯
      algorithm: "CRDT-Yjs",
      timestamp: new Date().toISOString(),
      testDuration: stats.monitoringDuration,

      // æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡
      performance: {
        averageLatency: stats.avgLatency,
        p95Latency: stats.p95Latency,
        averageNetworkLatency: stats.avgNetworkLatency,
        throughput: stats.updatesPerSecond,
        bandwidthEfficiency: stats.bandwidthKBps,
        totalOperations: stats.documentUpdates,
        userInteractions: stats.keystrokes,
      },

      // è¯¦ç»†ç»Ÿè®¡
      detailed: {
        documentUpdates: stats.documentUpdates,
        totalUpdateSize: stats.totalUpdateSize,
        avgUpdateSize: stats.avgUpdateSize,
        sentBytes: stats.sentBytes,
        receivedBytes: stats.receivedBytes,
        activeCollaborators: stats.activeCollaborators,
        awarenessChanges: stats.totalAwarenessChanges,
      },

      // æ•°æ®å®Œæ•´æ€§
      dataIntegrity: {
        latencySamples: stats.latencySamples,
        networkLatencySamples: stats.networkLatencySamples,
        networkEvents: stats.rawData.networkEvents.length,
        userOperations: stats.rawData.userOperations.length,
      },

      // åŸå§‹æ•°æ®
      rawData: stats.rawData,
    };
  }

  /**
   * é‡ç½®æ•°æ®
   */
  reset() {
    this.metrics = {
      documentUpdates: 0,
      totalUpdateSize: 0,
      updateTimes: [],
      networkEvents: [],
      connectionEvents: [],
      userOperations: [],
      keystrokes: 0,
      collaborators: new Map(),
      awarenessChanges: [],
      operationLatencies: [],
      networkLatencies: [],
    };

    this.startTime = performance.now();
    console.log("ğŸ”„ æ€§èƒ½ç›‘æ§æ•°æ®å·²é‡ç½®");
  }
}

export default RealYjsMonitor;
