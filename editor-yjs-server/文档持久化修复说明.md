# 文档持久化修复说明

## 🚨 问题描述

用户反馈：**每次重启服务器后，之前文档里面写的内容就丢了**

## 🔍 问题根源分析

### 1. **`saveDocState`函数参数错误**

- 原函数签名：`saveDocState(docId, ydoc, userId, teamId = null)`
- 调用方式：`saveDocState(roomName, ydoc)` （缺少必需的`userId`参数）
- 结果：保存操作失败，但错误被静默处理

### 2. **Debounce 延迟时间过长**

- 原配置：`2000ms` 延迟，`10000ms` 最大等待
- 问题：如果在这个时间窗口内重启服务器，未保存的更改会丢失

### 3. **缺乏定期保存机制**

- 仅依赖用户操作触发的 debounce 保存
- 长时间无操作的文档可能不会被保存

## ✅ 修复方案

### 1. **修复 `persistence.js` - `saveDocState` 函数**

#### 修改内容

```javascript
// 修改前
export async function saveDocState(docId, ydoc, userId, teamId = null)

// 修改后
export async function saveDocState(docId, ydoc, userId = null, teamId = null)
```

#### 新增逻辑

- **检查文档存在性**：先查询文档是否已存在
- **智能保存策略**：
  - 文档存在 → 仅更新内容和版本
  - 文档不存在 + 有 userId → 创建新文档
  - 文档不存在 + 无 userId → 记录警告，跳过保存

#### 代码实现

```javascript
const existingDoc = await Doc.findOne({ docId });

if (existingDoc) {
  // 文档已存在，仅更新内容
  const result = await Doc.updateOne(
    { docId },
    {
      $set: { content: jsonContent, lastUpdated: new Date() },
      $inc: { version: 1 },
    }
  );
} else if (userId) {
  // 创建新文档的逻辑
} else {
  console.warn(`⚠️ 文档 ${docId} 不存在且无法创建（缺少用户信息），跳过保存`);
}
```

### 2. **优化 `server.js` - 持久化配置**

#### Debounce 优化

```javascript
// 修改前
const persist = debounce(
  () => saveDocState(roomName, ydoc),
  2000, // 2秒延迟
  { maxWait: 10000 } // 10秒最大等待
);

// 修改后
const persist = debounce(
  async () => {
    try {
      await saveDocState(roomName, ydoc);
      console.log(`💾 文档 ${roomName} 自动保存成功`);
    } catch (err) {
      console.error(`❌ 文档 ${roomName} 自动保存失败:`, err);
    }
  },
  500, // 500ms延迟（更快响应）
  { maxWait: 2000 } // 2秒最大等待（更频繁保存）
);
```

#### 新增功能

- **异步错误处理**：包装在 try-catch 中
- **详细日志**：记录每次保存的成功/失败状态

### 3. **新增定期强制保存机制**

#### 实现方式

```javascript
// 每30秒强制保存所有文档
setInterval(async () => {
  if (docs.size > 0) {
    console.log(`⏰ 开始定期保存 ${docs.size} 个文档...`);
    for (const [docId, ydoc] of docs.entries()) {
      try {
        await saveDocState(docId, ydoc);
        console.log(`⏰ 定期保存文档 ${docId} 成功`);
      } catch (err) {
        console.error(`❌ 定期保存文档 ${docId} 失败:`, err);
      }
    }
    console.log(`✅ 定期保存完成`);
  }
}, 30000);
```

#### 作用

- **防止数据丢失**：即使用户长时间无操作，也会定期保存
- **服务器重启保护**：确保重启前数据已持久化

### 4. **增强退出时持久化处理**

#### 修改内容

```javascript
// 修改前
console.log("💾 正在持久化所有内存中的 Y.Doc ...");
for (const [docId, ydoc] of docs.entries()) {
  await saveDocState(docId, ydoc);
}
console.log("✅ 持久化完成，准备退出");

// 修改后
const docCount = docs.size;
let successCount = 0;
let failCount = 0;

for (const [docId, ydoc] of docs.entries()) {
  try {
    await saveDocState(docId, ydoc);
    successCount++;
    console.log(`✅ 退出保存文档 ${docId} 成功`);
  } catch (err) {
    failCount++;
    console.error(`❌ 退出保存文档 ${docId} 失败:`, err);
  }
}

console.log(
  `🎯 持久化完成: 成功 ${successCount}/${docCount} 个文档，失败 ${failCount} 个`
);
```

#### 新增功能

- **分文档错误处理**：单个文档保存失败不影响其他文档
- **详细统计信息**：显示成功/失败的文档数量
- **完整日志记录**：便于调试和监控

## 📊 修复效果

### 修复前的问题

- ❌ 保存操作失败（参数错误）
- ❌ 2-10 秒的保存延迟
- ❌ 重启服务器时数据丢失
- ❌ 错误信息不明确

### 修复后的改进

- ✅ 智能保存策略（自动判断文档状态）
- ✅ 0.5-2 秒的快速保存
- ✅ 每 30 秒定期强制保存
- ✅ 服务器退出时完整持久化
- ✅ 详细的成功/失败日志

## 🧪 验证方法

### 1. 启动测试

```bash
cd editor-yjs-server
npm start
```

### 2. 观察日志

应该看到以下类型的日志：

```
💾 文档 [docId] 自动保存成功
⏰ 开始定期保存 X 个文档...
⏰ 定期保存文档 [docId] 成功
✅ 定期保存完成
```

### 3. 重启测试

1. 在文档中输入内容
2. 等待保存日志出现
3. 重启服务器
4. 重新打开文档，内容应该保持不变

### 4. 数据库验证

检查 MongoDB 中的`docs`集合，确认：

- 文档内容正确保存
- `lastUpdated`字段有最新时间戳
- `version`字段正确递增

## 🎯 预期结果

修复完成后：

- ✅ **文档内容不再丢失**：重启服务器后内容完整保留
- ✅ **保存更及时**：更短的延迟时间，更频繁的保存
- ✅ **监控更完善**：详细的日志记录，便于问题排查
- ✅ **系统更稳定**：多重保存机制，确保数据安全

现在你的文档编辑器应该不会再出现重启服务器后内容丢失的问题了！
